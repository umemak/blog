<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on umemak</title><link>https://umemak.github.io/blog/tags/go/</link><description>Recent content in go on umemak</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 12 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://umemak.github.io/blog/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>MLTファイルを作る2</title><link>https://umemak.github.io/blog/posts/2022/08/12_mlt/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/08/12_mlt/</guid><description>silencedetectがなんか思ったのと違う感じで、代わりにPythonとffmpegで動画の無音部分をカットする - QiitaにあるPythonのプログラムの無音検出部分を使ってみた。 Goでもmkb218/gosndfile: Go bindings for libsndfileを使ったらできそうだけど、importしただ</description></item><item><title>MLTファイルを作る</title><link>https://umemak.github.io/blog/posts/2022/08/11_mlt/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/08/11_mlt/</guid><description>Shotcutのプロジェクトの保存形式がMLTで、中身はXMLのテキスト。 作業動画を編集していて、無音部分はスキップして尺を短くしたい。 無音部分はffmpegのsilencedetectで検出できるので、そのタイムスタンプで切ったShotcutプロジェクトを開けば、効率的に不要な部分を切り詰めつつ必</description></item><item><title>Go言語のエラーラッピング</title><link>https://umemak.github.io/blog/posts/2022/07/31_go_error_wrap/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/31_go_error_wrap/</guid><description>エラーのラッピングをすると何がうれしいのかという問いへの解答が見えた気がする。 ラッピングしない場合、元のエラーの文字列以外の情報が失われてしまうが、ラッピングするとエラー情報をアンラップして取り出すことができる。 失われてしまう情報が呼び出し元で必要な場合は、エラーをそのままreturnして返すか、必</description></item><item><title>sqlc</title><link>https://umemak.github.io/blog/posts/2022/07/28_sqlc/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/28_sqlc/</guid><description>別の調べものをしていて見つけたsqlc.dev | Compile SQL to type-safe Goを試してみた。 schema.sqlは、今までMySQLの起動時に読み込ませていたSQLファイルがそのまま使えた。 query.sqlもgoのmodelパッケージ内に書いていたSQLをコピペで作れた。 結構良いかも。</description></item><item><title>Goのエラー処理</title><link>https://umemak.github.io/blog/posts/2022/07/19_error_handring/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/19_error_handring/</guid><description>fmt.Errorf(&amp;quot;～～: %w&amp;quot;, err)の書き方にルールあるのかな、と思って調べたら、先人の記事があった。 fmt.Errorfのメッセージについての調査と、linterとしての実装について | CyberAgent Developers Blog いつもその時の雰囲気で書いていたので、こういったルールで揃えられるのは良い。 もうひとつ、tem</description></item><item><title>Goのredirect</title><link>https://umemak.github.io/blog/posts/2022/07/18_go_redirect/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/18_go_redirect/</guid><description>ログアウトの処理（GET /logout）実行後にトップページにリダイレクトしようとした。 http.Redirect(w, r, &amp;ldquo;/&amp;rdquo;, 301) おや？動作しない時がある。。 301だと、ブラウザはリダイレクト先を覚えて、次からはリダイレクト先を最初から叩くっぽい。 なので、302にしてあげないと思ったような動きにならない。 ところで、Goのhttpパッ</description></item><item><title>Goのtemplateのinclude</title><link>https://umemak.github.io/blog/posts/2022/07/18_go_include/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/18_go_include/</guid><description>テンプレートのincludeってどうやるんだっけ、と思って検索した。 Go の html/template でヘッダーやフッター等の共通化を実現する方法 · Yutaka 🍊 Kato なるほど、{{define &amp;quot;header&amp;quot;}}～{{end}}で定義して、{{template &amp;quot;header&amp;quot; .}}で呼び出すのか。</description></item><item><title>GoのJSON</title><link>https://umemak.github.io/blog/posts/2022/07/16_go_json/</link><pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/16_go_json/</guid><description>PocketBaseのユーザー作成をGoからHTTP叩いて実行しようとして、正常時とエラー時で戻ってくるJSONの形式が違っていた。 structを別々に用意して、Unmarshalでエラーになったらもう片方を使う？とか思ったけど、 golang は ゆるふわに JSON を扱えまぁす! — KaoriYaによると、interfa</description></item><item><title>Airを試す</title><link>https://umemak.github.io/blog/posts/2022/07/10_air/</link><pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/10_air/</guid><description>HTMLとかコード修正したときに手動で再起動するのが面倒なので、ホットリロードツールを導入してみた。 cosmtrek/air: ☁️ Live reload for Go apps $ go install github.com/cosmtrek/air@latest $ air init $ air __ _ ___ / /\ | | | |_) /_/--\ |_| |_| \_ , built with Go mkdir /home/umemak/workspace/eventsite_go/tmp watching . watching cmd watching cmd/eventsite watching db watching db/sql watching model watching model/user !exclude tmp watching web watching web/template building... no Go files in /home/umemak/workspace/eventsite_go failed to build, error: exit status 1 ^Ccleaning... see you again~ デフォルトだと、cmdの下のmain.goを見つけてく</description></item><item><title>Goアプリ</title><link>https://umemak.github.io/blog/posts/2022/07/09_eventsite_go/</link><pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate><guid>https://umemak.github.io/blog/posts/2022/07/09_eventsite_go/</guid><description>結局、フレームワークはgo-chi/chi: lightweight, idiomatic and composable router for building Go HTTP servicesを使うことにした。 理由は、認証で使いそうなパッケージgo-pkgz/auth: Authenticator via oauth2, direct, email and telegramのサンプルが使っていたから。 とりあえず、HTTPリクエストを受けてDB読み書きしてテンプレート加工して返すところまで</description></item></channel></rss>